% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/splogi_bridge_fblowrank.R
\name{splogi_bridge_fblowrank}
\alias{splogi_bridge_fblowrank}
\title{Spatial logistic model with bridge process random effect with low-rank structure (fully Bayes)}
\usage{
splogi_bridge_fblowrank(
  y,
  X,
  id,
  coords,
  coords_knot,
  priors = list(beta_intercept_scale = 10, beta_scale = 2.5, beta_df = Inf, logpriorphi =
    NULL, rho_lb = NULL, rho_ub = NULL),
  smoothness = 1.5,
  nburn = 100,
  nsave = 1000,
  nthin = 1,
  nparticle = 20,
  verbose = TRUE
)
}
\arguments{
\item{y}{N x 1 binary vector}

\item{X}{N x p fixed-effect design matrix, including intercept}

\item{id}{N x 1 vector of spatial location id. When N=n, it is point-referenced data}

\item{coords}{n x 2 matrix of spatial coordinates}

\item{coords_knot}{q x 2 matrix of knot coordinates}

\item{priors}{list of prior hyperparameters, see details}

\item{smoothness}{postive numeric, Matern smoothness parameter}

\item{nburn}{number of burn-in interation}

\item{nsave}{number of posterior samples}

\item{nthin}{thin-in rate}

\item{nparticle}{number of particles in particle marginal Metropolis-Hastings}

\item{verbose}{logical, whether to print progress}
}
\value{
Returns list of
\item{post_save}{a matrix of posterior samples (coda::mcmc) with nsave rows}
\item{u_save}{a matrix of posterior samples (coda::mcmc) of random effects, with nsave rows}
\item{betam_save}{a matrix of posterior samples (coda::mcmc) of population-averaged log odds, with nsave rows}
\item{loglik_save}{a nsave x n matrix of pointwise log-likelihood values, can be used for WAIC calculation.}
\item{priors}{list of hyperprior information}
\item{nsave}{number of MCMC samples}
\item{t_mcmc}{wall-clock time for running MCMC}
\item{t_premcmc}{wall-clock time for preprocessing before MCMC}
\item{y}{response vector}
\item{X}{fixed effect design matrix}
\item{coords}{a n x 2 matrix of Euclidean coordinates}
\item{coords_knot}{a q x 2 matrix of knot coordinates}
}
\description{
\deqn{
\operatorname{logit}\left[ \Pr(y_{ij} = 1 \mid X_{ij}, u(s_i)) \right]
  = X_{ij}^\top \beta + u(s_i)
}
where u(s) ~ Bridge process with parameter \eqn{\phi} and Matern correlation kernel with low-rank structure, i=1,...n corresponds to n spatial locations and
j=1,... N_i correspond to n_i responses at location i,
resulting data of size N = N_1 + ... N_n. The parameter \eqn{\phi} is estimated using fully Bayesian approach by placing prior on it.
}
\details{
Priors are specified by "priors" argument, which is a list of hyperparameters.
Specifically, we set zero centered normal or t prior for beta,
uniform prior for Matern range parameter rho (see fields::Matern),
and for phi, we use prior that induces half-Cauchy prior on the standard deviation of u.

priors is a named list with the following possible elements:
\describe{
\item{beta_intercept_scale}{scale of intercept parameter (default 10)}
\item{beta_scale}{scale of other beta parameters (default 2.5)}
\item{beta_df}{degrees of freedom for t prior on beta (default Inf, normal prior)}
\item{logpriorphi}{function for log-prior on phi (default prior that induces half-Cauchy prior on the standard deviation of u.)}
\item{rho_lb}{lower bound for range parameter rho (default min distance between coords)}
\item{rho_ub}{upper bound for range parameter rho (default max distance between coords)}
}
}
\examples{
\donttest{
library(spbridge)
data(gambia)
N = length(gambia$pos) # 2035
y = gambia$pos # binary response, N = 2035 by 1 vector
# define id based on spatial coords unique values
id = as.numeric(factor(paste(gambia$x, gambia$y)))
n = length(unique(id)) # 65
coords = unique(cbind(gambia$x, gambia$y)/1000) # n by 2 matrix, in km
# standardized covariates following Gelman et al (2008)
intercept = rep(1,N) # intercept
age = scale(gambia$age/365, scale = 2*sd(gambia$age/365)) # in years
netuse = gambia$netuse - mean(gambia$netuse)
treated = gambia$treated - mean(gambia$treated)
green = scale(gambia$green, scale = 2*sd(gambia$green))
green2 = scale(gambia$green^2, scale = 2*sd(gambia$green^2))
healthctr = gambia$phc - mean(gambia$phc)

X = cbind(intercept, age, netuse, treated, green, green2, healthctr)
colnames(X) = c("(Intercept)", "age", "netuse", "treated", "green", "green2", "healthctr")

centers = c(attr(age, "scaled:center"), mean(gambia$netuse), mean(gambia$treated),
            attr(green, "scaled:center"), attr(green2, "scaled:center"), mean(gambia$phc))
scales = c(attr(age, "scaled:scale"), 1, 1, attr(green, "scaled:scale"), attr(green2, "scaled:scale"), 1)

coords_knot = expand.grid(seq(quantile(coords[,1], 0.1), quantile(coords[,1], 0.9), length.out = 5),
                         seq(quantile(coords[,2], 0.1), quantile(coords[,2], 0.9), length.out = 5))

#
# uncomment below
#
# fit_bridge_fblowrank = spbridge::splogi_bridge_fblowrank(y = y,
#                                         X = X,
#                                         id = id,
#                                         priors = list(beta_intercept_scale = 10,
#                                                       beta_scale = 2.5, beta_df = Inf,
#                                                       rho_lb = 0.01, rho_ub = 100),
#                                         coords = coords,
#                                         coords_knot = coords_knot,
#                                         smoothness = 0.5, nburn = 1000, nsave = 10000, nthin = 1)
}


}
